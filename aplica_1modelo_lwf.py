# -*- coding: utf-8 -*-
"""Aplica_LwF_JaTreinado.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17v1WxglCifH0jHpCui7ZcJPRStCe5a1X
"""

from __future__ import division, print_function
import argparse
import copy
import json
import warnings

import dataset
from loaddata_paper import *
import networks as net
import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
import torchnet as tnt
import utils as utils
from prune import SparsePruner
from torch.autograd import Variable
from tqdm import tqdm
import collections
import pickle
import numpy as np
from sklearn.model_selection import StratifiedKFold
import math
import matplotlib.pyplot as plt

import os
from ELLA import ELLA
from functions_apply_lwf import *
import sys 
import csv

def Aplica_1modelo( i, j, count ):
  
  modelpath = '/home/regina.alves/results/lwf_res/SENS90/2Real_3Manaus/'
  ipre = 1 # 0 se nao tiver pretreino, 1 se tiver pretreino (soma em ilayer do modelo)
  loadmode = "outras"
  taskName = "Manaus"
  nomeDoenca = "TB"
  imodel = i
  filename = 'aux_lr0.0001_test' + str(i) + '_val' + str(j) + '.pt'
  modelname = modelpath + filename
  calcula_roc = True
  nkfolds = 1

  Sens90 = False #determina que ponto de operação tem que ser com sensibilidade > 90%
  if count == 1:
     csvOld = ''
  else:
    csvOld = modelpath + taskName + str(count-1) + '.csv'
  
  csvNew = modelpath + taskName + str(count) + '.csv'
  Results_header = [ 'Caso',	'Sens ' + nomeDoenca + ' Val',	'Spec ' + nomeDoenca + ' Val',	'SP ' + nomeDoenca + ' Val',	'Sens ' + nomeDoenca + ' Treino',	'Spec ' + nomeDoenca + ' Treino',	'SP ' + nomeDoenca + ' Treino',	'Sens ' + nomeDoenca + ' Treino + Val',	'Spec ' + nomeDoenca + ' Treino + Val',	'SP ' + nomeDoenca + ' Treino + Val',	'Sens ' + nomeDoenca + ' Teste',	'Spec ' + nomeDoenca + ' Teste',	'SP ' + nomeDoenca + ' Teste',	'Sens ' + nomeDoenca + ' Todos',	'Spec ' + nomeDoenca + ' Todos',	'SP ' + nomeDoenca + ' Todos' ]	


  #---- Paths for already loaded data. Always have ntasks dimension, but if the task don't have the pickle
  #with the loaded data =  "false"
  if taskName == "Stanford":
    taskPath = "/home/regina.alves/dados_radiografias/infoStanford.pkl" #ou False se nao for task antiga
    #Information about folds - different for TB to follow Otto's partition
    infoTestFold = "/home/regina.alves/info/test_folds_stanford.pkl" #ou False se nao for task antiga
    partition_path = False #pickle com partition do Otto
    ilayer = 0 + ipre #qual é o id do classificador da tarefa sendo avaliada. Lembrar que =0 é o dataset genérico, primeira doença
            #está no 1. Se for a última, pode usar -1   
  elif taskName == "Shenzhen":
    taskPath = "/home/regina.alves/dados_radiografias/infoShenPartitionOtto.pkl"
    #Information about folds - different for TB to follow Otto's partition
    infoTestFold = False #"/home/regina.alves/info/test_folds_stanford.pkl" #ou False se nao for task antiga
    partition_path = "/home/regina.alves/info/partition.pkl" #pickle com partition do Otto
    ilayer = 1 + ipre #qual é o id do classificador da tarefa sendo avaliada. Lembrar que =0 é o dataset genérico, primeira doença
            #está no 1. Se for a última, pode usar -1   

  elif loadmode == "outras" and taskName == "Manaus":
    csv_path = '/home/brics/public/brics_data/Manaus/c_manaus/raw/Manaus_c_manaus_table_from_raw.csv'
    partition_path = "/home/brics/public/brics_data/Manaus/c_manaus/raw/splits.pkl"
    ilayer = 2 + ipre

  usecuda = True

  #START CODE

  #Leitura do csv antigo
  Lista_csv = []
  if csvOld != '':
    with open( csvOld, mode='r') as csv_file:
        csv_reader = csv.DictReader(csv_file)
        for row in csv_reader:
            Lista_csv.append( row)
  Data_csv = {}
  Data_csv['Caso'] = filename
  #-------------------------------------------------------------------------
  ################################################################################################
  #loading data, names, labels for tasks that are not TB
  if loadmode == 'Stanford':
    datataskaux, labelsaux, namesImgaux = Read_pickle_tasksPaths( dataPartition )
    datatask, labels, namesImg = [], [], []
    datatask.append( datataskaux.numpy() )#.transpose(0,3,2,1) )
    print( datatask[0].size )
    labels.append( labelsaux.numpy() )
    namesImg.append( namesImgaux )
    Id_aux = Read_Id_Test( partitionPickle, namesImg[0] )
    Id_folds = []
    Id_folds.append( Id_aux )
    print("Loaded " + str(len(labels)) + " real images from other task")

  #------ loading data, names, labels for tasks that are real TB
  if loadmode != 'Stanford' and loadmode != 'outras':
    datataskaux, labelsaux, namesImgaux = Read_pickle_tasksPaths( dataPartition )
    #datatask, labels, namesImg = [], [], []
    datatask = datataskaux.numpy()
    labels = labelsaux.numpy() 
    namesImg = namesImgaux 
    a_file = open(partition_path, "rb")
    partition = pickle.load(a_file)
    a_file.close()
    print("Loaded " + str(len(labels)) + " real images from partition")

  if loadmode == 'outras' and taskName == 'MC':
    datatask, labels, namesImg = Read_pickle_others( dataPartition )

  if loadmode == 'outras' and taskName == 'Manaus':
    datatask, labels, namesImg = Load_Names_Manaus( csv_path )
    a_file = open(partition_path, "rb")
    partition = pickle.load(a_file)
    a_file.close()
    
  ################################################################################################

  print("Inicio da rotina para operation point")
  #Chose operation point

  #Define o vetor com as especificidades discretas, de 2 em 2%. Para todos os 10 modelos, irei calcular a sensibilidade correspondente usando a funcao interpola.
  nValues = 49
  ndeltas = 120
  specDiscrete = []   
  for i in range( nValues ):
    specDiscrete.append( i*0.02 )
  sensDiscrete = []

  #Define ponto de operação e curva ROC para pneumo-----------------------------------------------------
  #-----------------------------------------------------------------------------------------------------
  deltaOp =  0 
  if ( calcula_roc ):
      print("Modelname é " + str( modelname ))
      if ( taskName == 'Stanford' ):
          datalwf, labellwf, namelwf = Define_Data_Fold_Stanford( imodel, j, Id_folds, datas,
                                          labels, namesImg )  

      elif ( taskName == 'Shenzhen' ):
          datalwf, labellwf, namelwf = Define_Data_Fold_Partition( imodel, j, partition, datas,
                                  labels, namesImg )
          
      elif ( taskName == 'MC' ):
          datalwf, labellwf, namelwf = Define_Data_Fold_Others( imodel, j, datas, labels, namesImg )
        
      elif loadmode == 'outras' and taskName == 'Manaus':
        datalwf, labellwf, namelwf = Define_Data_Fold_Partition_Manaus( imodel, j, partition, datatask, labels, namesImg )                                      

      print("Calculando variacoes de delta para modelo " + str(imodel))
      sensAux, Class_Model, deltas = Calcula_ROC( modelname, specDiscrete,
                      datalwf, labellwf, namelwf, ndeltas, ilayer = ilayer  )

      sensDiscrete.append( sensAux )

      #Calcula delta de operação com média sens>90% e maior SP para relatar resultados, caso se queira
      deltaOp = Calcula_Delta_Operacao( Class_Model, deltas, Sens90 )
      print("Delta op = " + str(deltaOp))


  ##################################################################################################

  """# Apply a dataset to all classifiers"""

  #Aplicar modelo aos dados -  estrutura separada por folds para cálculos de estatísticas
  Class_Train = Modeltasks( nkfolds )
  Class_Val = Modeltasks( nkfolds )
  Class_Test = Modeltasks( nkfolds )
  Class_TrainVal = Modeltasks( nkfolds )
  Class_All = Modeltasks( nkfolds )

  print("Aplica modelo ao dataset")

  if( taskName == 'Shenzhen' ):
      datalwf, labellwf, namelwf = Define_Data_Fold_Partition( imodel, j, partition, datas,
                                  labels, namesImg )
                                  
  elif (  taskName == 'Stanford' ):
      datalwf, labellwf, namelwf = Define_Data_Fold_Stanford( imodel, j, Id_folds, datas,
                              labels, namesImg )    

  elif (  taskName == 'MC' ):   
      datalwf, labellwf, namelwf = Define_Data_Fold_Others( imodel, j, datas, labels, namesImg )
        
  print("Classificador aos dados de teste ")
  output_all, labels_all, names_all = eval_test( usecuda, modelname, datalwf[ 'test' ] , labellwf[ 'test' ],  
                                      namelwf[ 'test' ],  ilayer = ilayer )

  Calculate_Classifications_eval( output_all, labels_all, names_all, Class_Test.folder[ 0 ], deltaOp )

  print("Classificador aos dados de validação")
  output_all, labels_all, names_all = eval_test( usecuda, modelname, datalwf[ 'val' ] , labellwf[ 'val' ],  
                                      namelwf[ 'val' ],  ilayer = ilayer )

  print("Delta op = " + str(deltaOp))
  Calculate_Classifications_eval( output_all, labels_all, names_all, Class_Val.folder[ 0 ], deltaOp )

  print("Classificador aos dados de treino ")
  output_all, labels_all, names_all = eval_test( usecuda, modelname, datalwf[ 'train' ] , labellwf[ 'train' ],  
                                      namelwf[ 'train' ],  ilayer = ilayer )

  Calculate_Classifications_eval( output_all, labels_all, names_all, Class_Train.folder[ 0 ], deltaOp )


  print("Classificador aos dados de treino + val")
  output_all, labels_all, names_all = eval_test( usecuda, modelname, datalwf[ 'trainval' ] , labellwf[ 'trainval' ],  
                                      namelwf[ 'trainval' ],  ilayer = ilayer )

  Calculate_Classifications_eval( output_all, labels_all, names_all, Class_TrainVal.folder[ 0 ], deltaOp )


  print("Classificador a todos os dados")
  output_all, labels_all, names_all = eval_test( usecuda, modelname, datalwf[ 'all' ] , labellwf[ 'all' ],  
                                      namelwf[ 'all' ],  ilayer = ilayer )

  Calculate_Classifications_eval( output_all, labels_all, names_all, Class_All.folder[ 0 ], deltaOp )

  #Imprimir tudo no csv

  Data_csv['Sens ' + nomeDoenca + ' Treino'] = round( 100 * Class_Train.folder[ 0 ].sens, 1 )
  Data_csv['Spec ' + nomeDoenca + ' Treino'] = round( 100 * Class_Train.folder[ 0 ].spec, 1 )
  Data_csv['SP ' + nomeDoenca + ' Treino'] = round( 100 * Class_Train.folder[ 0 ].sp, 1 )
  Data_csv['Sens ' + nomeDoenca + ' Treino + Val'] = round( 100 * Class_TrainVal.folder[ 0 ].sens, 1 )
  Data_csv['Spec ' + nomeDoenca + ' Treino + Val'] = round( 100 * Class_TrainVal.folder[ 0 ].spec, 1 )
  Data_csv['SP ' + nomeDoenca + ' Treino + Val'] = round( 100 * Class_TrainVal.folder[ 0 ].sp, 1 )
  Data_csv['Sens ' + nomeDoenca + ' Teste'] = round( 100 * Class_Test.folder[ 0 ].sens, 1 )
  Data_csv['Spec ' + nomeDoenca + ' Teste'] = round( 100 * Class_Test.folder[ 0 ].spec, 1 )
  Data_csv['SP ' + nomeDoenca + ' Teste'] = round( 100 * Class_Test.folder[ 0 ].sp, 1 )
  Data_csv['Sens ' + nomeDoenca + ' Val'] = round( 100 * Class_Val.folder[ 0 ].sens, 1 )
  Data_csv['Spec ' + nomeDoenca + ' Val'] = round( 100 * Class_Val.folder[ 0 ].spec, 1 )
  Data_csv['SP ' + nomeDoenca + ' Val'] = round( 100 * Class_Val.folder[ 0 ].sp, 1 )
  Data_csv['Sens ' + nomeDoenca + ' Todos'] = round( 100 * Class_All.folder[ 0 ].sens, 1 )
  Data_csv['Spec ' + nomeDoenca + ' Todos'] = round( 100 * Class_All.folder[ 0 ].spec, 1 )
  Data_csv['SP ' + nomeDoenca + ' Todos'] = round( 100 * Class_All.folder[ 0 ].sp, 1 )

  Lista_csv.append( Data_csv )
  with open( csvNew, 'w') as file:
      # Create a CSV dictionary writer and add the student header as field names
      writer = csv.DictWriter(file, fieldnames=Results_header)
      # Use writerows() not writerow()
      writer.writeheader()
      writer.writerows( Lista_csv )
    
  Create_Sets_with_VPFPVNFN_from_all_folds ( Class_Train )
  Create_Sets_with_VPFPVNFN_from_all_folds ( Class_TrainVal )
  Create_Sets_with_VPFPVNFN_from_all_folds ( Class_Test )
  Create_Sets_with_VPFPVNFN_from_all_folds ( Class_Val )

count = 81
for i in range(0,10):
  for j in range(0,9):
    if i!=j:
      continue
    count += 1
    print("I = " + str(i) + "J = " + str(j))
    Aplica_1modelo( i, j, count )